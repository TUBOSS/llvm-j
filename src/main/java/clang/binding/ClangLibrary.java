package clang.binding;

import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.NativeLong;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.Structure;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
import java.nio.IntBuffer;
//import java.util.Date;
//import java.util.GregorianCalendar;


/**
 * JNA Wrapper for library <b>clang</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public class ClangLibrary implements Library {
	
	public static final String JNA_LIBRARY_NAME = "clang";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(ClangLibrary.JNA_LIBRARY_NAME);
	static { Native.register(ClangLibrary.JNA_LIBRARY_NAME); }
	//public static final ClangLibrary INSTANCE = (ClangLibrary)Native.loadLibrary("clang", clang.ClangLibrary.class);
	
	public static interface CXAvailabilityKind {
		/// \brief The entity is available.
		public static final int CXAvailability_Available = (int)0;
		/**
		 * \brief The entity is available, but has been deprecated (and its use is<br>
		 * not recommended).
		 */
		public static final int CXAvailability_Deprecated = (int)1;
		/// \brief The entity is not available; any use of it will be an error.
		public static final int CXAvailability_NotAvailable = (int)2;
		/**
		 * \brief The entity is available, but not accessible; any use of it will be<br>
		 * an error.
		 */
		public static final int CXAvailability_NotAccessible = (int)3;
	};
	public static interface CXDiagnosticSeverity {
		/**
		 * \brief A diagnostic that has been suppressed, e.g., by a command-line<br>
		 * option.
		 */
		public static final int CXDiagnostic_Ignored = (int)0;
		/**
		 * \brief This diagnostic is a note that should be attached to the<br>
		 * previous (non-note) diagnostic.
		 */
		public static final int CXDiagnostic_Note = (int)1;
		/**
		 * \brief This diagnostic indicates suspicious code that may not be<br>
		 * wrong.
		 */
		public static final int CXDiagnostic_Warning = (int)2;
		/// \brief This diagnostic indicates that the code is ill-formed.
		public static final int CXDiagnostic_Error = (int)3;
		/**
		 * \brief This diagnostic indicates that the code is ill-formed such<br>
		 * that future parser recovery is unlikely to produce useful<br>
		 * results.
		 */
		public static final int CXDiagnostic_Fatal = (int)4;
	};
	public static interface CXDiagnosticDisplayOptions {
		/**
		 * \brief Display the source-location information where the<br>
		 * diagnostic was located.<br>
		 * * When set, diagnostics will be prefixed by the file, line, and<br>
		 * (optionally) column to which the diagnostic refers. For example,<br>
		 * * \code<br>
		 * test.c:28: warning: extra tokens at end of #endif directive<br>
		 * \endcode<br>
		 * * This option corresponds to the clang flag \c -fshow-source-location.
		 */
		public static final int CXDiagnostic_DisplaySourceLocation = (int)0x01;
		/**
		 * \brief If displaying the source-location information of the<br>
		 * diagnostic, also include the column number.<br>
		 * * This option corresponds to the clang flag \c -fshow-column.
		 */
		public static final int CXDiagnostic_DisplayColumn = (int)0x02;
		/**
		 * \brief If displaying the source-location information of the<br>
		 * diagnostic, also include information about source ranges in a<br>
		 * machine-parsable format.<br>
		 * * This option corresponds to the clang flag<br>
		 * \c -fdiagnostics-print-source-range-info.
		 */
		public static final int CXDiagnostic_DisplaySourceRanges = (int)0x04;
		/**
		 * \brief Display the option name associated with this diagnostic, if any.<br>
		 * * The option name displayed (e.g., -Wconversion) will be placed in brackets<br>
		 * after the diagnostic text. This option corresponds to the clang flag<br>
		 * \c -fdiagnostics-show-option.
		 */
		public static final int CXDiagnostic_DisplayOption = (int)0x08;
		/**
		 * \brief Display the category number associated with this diagnostic, if any.<br>
		 * * The category number is displayed within brackets after the diagnostic text.<br>
		 * This option corresponds to the clang flag <br>
		 * \c -fdiagnostics-show-category=id.
		 */
		public static final int CXDiagnostic_DisplayCategoryId = (int)0x10;
		/**
		 * \brief Display the category name associated with this diagnostic, if any.<br>
		 * * The category name is displayed within brackets after the diagnostic text.<br>
		 * This option corresponds to the clang flag <br>
		 * \c -fdiagnostics-show-category=name.
		 */
		public static final int CXDiagnostic_DisplayCategoryName = (int)0x20;
	};
	public static interface CXTranslationUnit_Flags {
		/**
		 * \brief Used to indicate that no special translation-unit options are<br>
		 * needed.
		 */
		public static final int CXTranslationUnit_None = (int)0x0;
		/**
		 * \brief Used to indicate that the parser should construct a "detailed"<br>
		 * preprocessing record, including all macro definitions and instantiations.<br>
		 * * Constructing a detailed preprocessing record requires more memory<br>
		 * and time to parse, since the information contained in the record<br>
		 * is usually not retained. However, it can be useful for<br>
		 * applications that require more detailed information about the<br>
		 * behavior of the preprocessor.
		 */
		public static final int CXTranslationUnit_DetailedPreprocessingRecord = (int)0x01;
		/**
		 * \brief Used to indicate that the translation unit is incomplete.<br>
		 * * When a translation unit is considered "incomplete", semantic<br>
		 * analysis that is typically performed at the end of the<br>
		 * translation unit will be suppressed. For example, this suppresses<br>
		 * the completion of tentative declarations in C and of<br>
		 * instantiation of implicitly-instantiation function templates in<br>
		 * C++. This option is typically used when parsing a header with the<br>
		 * intent of producing a precompiled header.
		 */
		public static final int CXTranslationUnit_Incomplete = (int)0x02;
		/**
		 * \brief Used to indicate that the translation unit should be built with an <br>
		 * implicit precompiled header for the preamble.<br>
		 * * An implicit precompiled header is used as an optimization when a<br>
		 * particular translation unit is likely to be reparsed many times<br>
		 * when the sources aren't changing that often. In this case, an<br>
		 * implicit precompiled header will be built containing all of the<br>
		 * initial includes at the top of the main file (what we refer to as<br>
		 * the "preamble" of the file). In subsequent parses, if the<br>
		 * preamble or the files in it have not changed, \c<br>
		 * clang_reparseTranslationUnit() will re-use the implicit<br>
		 * precompiled header to improve parsing performance.
		 */
		public static final int CXTranslationUnit_PrecompiledPreamble = (int)0x04;
		/**
		 * \brief Used to indicate that the translation unit should cache some<br>
		 * code-completion results with each reparse of the source file.<br>
		 * * Caching of code-completion results is a performance optimization that<br>
		 * introduces some overhead to reparsing but improves the performance of<br>
		 * code-completion operations.
		 */
		public static final int CXTranslationUnit_CacheCompletionResults = (int)0x08;
		/**
		 * \brief DEPRECATED: Enable precompiled preambles in C++.<br>
		 * * Note: this is a *temporary* option that is available only while<br>
		 * we are testing C++ precompiled preamble support. It is deprecated.
		 */
		public static final int CXTranslationUnit_CXXPrecompiledPreamble = (int)0x10;
		/**
		 * \brief DEPRECATED: Enabled chained precompiled preambles in C++.<br>
		 * * Note: this is a *temporary* option that is available only while<br>
		 * we are testing C++ precompiled preamble support. It is deprecated.
		 */
		public static final int CXTranslationUnit_CXXChainedPCH = (int)0x20;
		/**
		 * \brief Used to indicate that the "detailed" preprocessing record,<br>
		 * if requested, should also contain nested macro expansions.<br>
		 * * Nested macro expansions (i.e., macro expansions that occur<br>
		 * inside another macro expansion) can, in some code bases, require<br>
		 * a large amount of storage to due preprocessor metaprogramming. Moreover,<br>
		 * its fairly rare that this information is useful for libclang clients.
		 */
		public static final int CXTranslationUnit_NestedMacroExpansions = (int)0x40;
		/**
		 * SKIPPED:<br>
		 * \brief Legacy name to indicate that the "detailed" preprocessing record,<br>
		 * if requested, should contain nested macro expansions.<br>
		 * * \see CXTranslationUnit_NestedMacroExpansions for the current name for this<br>
		 * value, and its semantics. This is just an alias.<br>
		 * <i>native declaration : line 907</i><br>
		 * \brief Legacy name to indicate that the "detailed" preprocessing record,<br>
		 * if requested, should contain nested macro expansions.<br>
		 * * \see CXTranslationUnit_NestedMacroExpansions for the current name for this<br>
		 * value, and its semantics. This is just an alias.<br>
		 * /<br>
		 * CXTranslationUnit_NestedMacroInstantiations = CXTranslationUnit_NestedMacroExpansions
		 */
	};
	public static interface CXSaveTranslationUnit_Flags {
		/// \brief Used to indicate that no special saving options are needed.
		public static final int CXSaveTranslationUnit_None = (int)0x0;
	};
	public static interface CXSaveError {
		/// \brief Indicates that no error occurred while saving a translation unit.
		public static final int CXSaveError_None = (int)0;
		/**
		 * \brief Indicates that an unknown error occurred while attempting to save<br>
		 * the file.<br>
		 * * This error typically indicates that file I/O failed when attempting to <br>
		 * write the file.
		 */
		public static final int CXSaveError_Unknown = (int)1;
		/**
		 * \brief Indicates that errors during translation prevented this attempt<br>
		 * to save the translation unit.<br>
		 * <br>
		 * Errors that prevent the translation unit from being saved can be<br>
		 * extracted using \c clang_getNumDiagnostics() and \c clang_getDiagnostic().
		 */
		public static final int CXSaveError_TranslationErrors = (int)2;
		/**
		 * \brief Indicates that the translation unit to be saved was somehow<br>
		 * invalid (e.g., NULL).
		 */
		public static final int CXSaveError_InvalidTU = (int)3;
	};
	public static interface CXReparse_Flags {
		/// \brief Used to indicate that no special reparsing options are needed.
		public static final int CXReparse_None = (int)0x0;
	};
	public static interface CXTUResourceUsageKind {
		public static final int CXTUResourceUsage_AST = (int)1;
		public static final int CXTUResourceUsage_Identifiers = (int)2;
		public static final int CXTUResourceUsage_Selectors = (int)3;
		public static final int CXTUResourceUsage_GlobalCompletionResults = (int)4;
		public static final int CXTUResourceUsage_SourceManagerContentCache = (int)5;
		public static final int CXTUResourceUsage_AST_SideTables = (int)6;
		public static final int CXTUResourceUsage_SourceManager_Membuffer_Malloc = (int)7;
		public static final int CXTUResourceUsage_SourceManager_Membuffer_MMap = (int)8;
		public static final int CXTUResourceUsage_ExternalASTSource_Membuffer_Malloc = (int)9;
		public static final int CXTUResourceUsage_ExternalASTSource_Membuffer_MMap = (int)10;
		public static final int CXTUResourceUsage_Preprocessor = (int)11;
		public static final int CXTUResourceUsage_PreprocessingRecord = (int)12;
		public static final int CXTUResourceUsage_SourceManager_DataStructures = (int)13;
		public static final int CXTUResourceUsage_Preprocessor_HeaderSearch = (int)14;
		/**
		 * SKIPPED:<br>
		 * <i>native declaration : line 1154</i><br>
		 * CXTUResourceUsage_MEMORY_IN_BYTES_BEGIN = CXTUResourceUsage_AST
		 */
		/**
		 * SKIPPED:<br>
		 * <i>native declaration : line 1155</i><br>
		 * CXTUResourceUsage_MEMORY_IN_BYTES_END = CXTUResourceUsage_Preprocessor_HeaderSearch
		 */
		/**
		 * SKIPPED:<br>
		 * <i>native declaration : line 1158</i><br>
		 * CXTUResourceUsage_First = CXTUResourceUsage_AST
		 */
		/**
		 * SKIPPED:<br>
		 * <i>native declaration : line 1159</i><br>
		 * CXTUResourceUsage_Last = CXTUResourceUsage_Preprocessor_HeaderSearch
		 */
	};
	public static interface CXCursorKind {
		/**
		 * \brief A declaration whose specific kind is not exposed via this<br>
		 * interface.<br>
		 * * Unexposed declarations have the same operations as any other kind<br>
		 * of declaration; one can extract their location information,<br>
		 * spelling, find their definitions, etc. However, the specific kind<br>
		 * of the declaration is not reported.
		 */
		public static final int CXCursor_UnexposedDecl = (int)1;
		/// \brief A C or C++ struct.
		public static final int CXCursor_StructDecl = (int)2;
		/// \brief A C or C++ union.
		public static final int CXCursor_UnionDecl = (int)3;
		/// \brief A C++ class.
		public static final int CXCursor_ClassDecl = (int)4;
		/// \brief An enumeration.
		public static final int CXCursor_EnumDecl = (int)5;
		/**
		 * \brief A field (in C) or non-static data member (in C++) in a<br>
		 * struct, union, or C++ class.
		 */
		public static final int CXCursor_FieldDecl = (int)6;
		/// \brief An enumerator constant.
		public static final int CXCursor_EnumConstantDecl = (int)7;
		/// \brief A function.
		public static final int CXCursor_FunctionDecl = (int)8;
		/// \brief A variable.
		public static final int CXCursor_VarDecl = (int)9;
		/// \brief A function or method parameter.
		public static final int CXCursor_ParmDecl = (int)10;
		/// \brief An Objective-C @interface.
		public static final int CXCursor_ObjCInterfaceDecl = (int)11;
		/// \brief An Objective-C @interface for a category.
		public static final int CXCursor_ObjCCategoryDecl = (int)12;
		/// \brief An Objective-C @protocol declaration.
		public static final int CXCursor_ObjCProtocolDecl = (int)13;
		/// \brief An Objective-C @property declaration.
		public static final int CXCursor_ObjCPropertyDecl = (int)14;
		/// \brief An Objective-C instance variable.
		public static final int CXCursor_ObjCIvarDecl = (int)15;
		/// \brief An Objective-C instance method.
		public static final int CXCursor_ObjCInstanceMethodDecl = (int)16;
		/// \brief An Objective-C class method.
		public static final int CXCursor_ObjCClassMethodDecl = (int)17;
		/// \brief An Objective-C @implementation.
		public static final int CXCursor_ObjCImplementationDecl = (int)18;
		/// \brief An Objective-C @implementation for a category.
		public static final int CXCursor_ObjCCategoryImplDecl = (int)19;
		/// \brief A typedef
		public static final int CXCursor_TypedefDecl = (int)20;
		/// \brief A C++ class method.
		public static final int CXCursor_CXXMethod = (int)21;
		/// \brief A C++ namespace.
		public static final int CXCursor_Namespace = (int)22;
		/// \brief A linkage specification, e.g. 'extern "C"'.
		public static final int CXCursor_LinkageSpec = (int)23;
		/// \brief A C++ constructor.
		public static final int CXCursor_Constructor = (int)24;
		/// \brief A C++ destructor.
		public static final int CXCursor_Destructor = (int)25;
		/// \brief A C++ conversion function.
		public static final int CXCursor_ConversionFunction = (int)26;
		/// \brief A C++ template type parameter.
		public static final int CXCursor_TemplateTypeParameter = (int)27;
		/// \brief A C++ non-type template parameter.
		public static final int CXCursor_NonTypeTemplateParameter = (int)28;
		/// \brief A C++ template template parameter.
		public static final int CXCursor_TemplateTemplateParameter = (int)29;
		/// \brief A C++ function template.
		public static final int CXCursor_FunctionTemplate = (int)30;
		/// \brief A C++ class template.
		public static final int CXCursor_ClassTemplate = (int)31;
		/// \brief A C++ class template partial specialization.
		public static final int CXCursor_ClassTemplatePartialSpecialization = (int)32;
		/// \brief A C++ namespace alias declaration.
		public static final int CXCursor_NamespaceAlias = (int)33;
		/// \brief A C++ using directive.
		public static final int CXCursor_UsingDirective = (int)34;
		/// \brief A C++ using declaration.
		public static final int CXCursor_UsingDeclaration = (int)35;
		/// \brief A C++ alias declaration
		public static final int CXCursor_TypeAliasDecl = (int)36;
		/// \brief An Objective-C @synthesize definition.
		public static final int CXCursor_ObjCSynthesizeDecl = (int)37;
		/// \brief An Objective-C @dynamic definition.
		public static final int CXCursor_ObjCDynamicDecl = (int)38;
		/// \brief An access specifier.
		public static final int CXCursor_CXXAccessSpecifier = (int)39;
		/**
		 * SKIPPED:<br>
		 * <i>native declaration : line 1300</i><br>
		 * CXCursor_FirstDecl = CXCursor_UnexposedDecl
		 */
		/**
		 * SKIPPED:<br>
		 * <i>native declaration : line 1301</i><br>
		 * CXCursor_LastDecl = CXCursor_CXXAccessSpecifier
		 */
		/**
		 * References<br>
		 * Decl references
		 */
		public static final int CXCursor_FirstRef = (int)40;
		public static final int CXCursor_ObjCSuperClassRef = (int)40;
		public static final int CXCursor_ObjCProtocolRef = (int)41;
		public static final int CXCursor_ObjCClassRef = (int)42;
		/**
		 * \brief A reference to a type declaration.<br>
		 * * A type reference occurs anywhere where a type is named but not<br>
		 * declared. For example, given:<br>
		 * * \code<br>
		 * typedef unsigned size_type;<br>
		 * size_type size;<br>
		 * \endcode<br>
		 * * The typedef is a declaration of size_type (CXCursor_TypedefDecl),<br>
		 * while the type of the variable "size" is referenced. The cursor<br>
		 * referenced by the type of size is the typedef for size_type.
		 */
		public static final int CXCursor_TypeRef = (int)43;
		public static final int CXCursor_CXXBaseSpecifier = (int)44;
		/**
		 * \brief A reference to a class template, function template, template<br>
		 * template parameter, or class template partial specialization.
		 */
		public static final int CXCursor_TemplateRef = (int)45;
		/// \brief A reference to a namespace or namespace alias.
		public static final int CXCursor_NamespaceRef = (int)46;
		/**
		 * \brief A reference to a member of a struct, union, or class that occurs in <br>
		 * some non-expression context, e.g., a designated initializer.
		 */
		public static final int CXCursor_MemberRef = (int)47;
		/**
		 * \brief A reference to a labeled statement.<br>
		 * * This cursor kind is used to describe the jump to "start_over" in the <br>
		 * goto statement in the following example:<br>
		 * * \code<br>
		 *   start_over:<br>
		 *     ++counter;<br>
		 * *     goto start_over;<br>
		 * \endcode<br>
		 * * A label reference cursor refers to a label statement.
		 */
		public static final int CXCursor_LabelRef = (int)48;
		/**
		 * \brief A reference to a set of overloaded functions or function templates<br>
		 * that has not yet been resolved to a specific function or function template.<br>
		 * * An overloaded declaration reference cursor occurs in C++ templates where<br>
		 * a dependent name refers to a function. For example:<br>
		 * * \code<br>
		 * template<typename T> void swap(T&, T&);<br>
		 * * struct X { ... };<br>
		 * void swap(X&, X&);<br>
		 * * template<typename T><br>
		 * void reverse(T* first, T* last) {<br>
		 *   while (first < last - 1) {<br>
		 *     swap(*first, *--last);<br>
		 *     ++first;<br>
		 *   }<br>
		 * }<br>
		 * * struct Y { };<br>
		 * void swap(Y&, Y&);<br>
		 * \endcode<br>
		 * * Here, the identifier "swap" is associated with an overloaded declaration<br>
		 * reference. In the template definition, "swap" refers to either of the two<br>
		 * "swap" functions declared above, so both results will be available. At<br>
		 * instantiation time, "swap" may also refer to other functions found via<br>
		 * argument-dependent lookup (e.g., the "swap" function at the end of the<br>
		 * example).<br>
		 * * The functions \c clang_getNumOverloadedDecls() and <br>
		 * \c clang_getOverloadedDecl() can be used to retrieve the definitions<br>
		 * referenced by this cursor.
		 */
		public static final int CXCursor_OverloadedDeclRef = (int)49;
		/**
		 * SKIPPED:<br>
		 * <i>native declaration : line 1394</i><br>
		 * CXCursor_LastRef = CXCursor_OverloadedDeclRef
		 */
		/// Error conditions
		public static final int CXCursor_FirstInvalid = (int)70;
		public static final int CXCursor_InvalidFile = (int)70;
		public static final int CXCursor_NoDeclFound = (int)71;
		public static final int CXCursor_NotImplemented = (int)72;
		public static final int CXCursor_InvalidCode = (int)73;
		/**
		 * SKIPPED:<br>
		 * <i>native declaration : line 1402</i><br>
		 * CXCursor_LastInvalid = CXCursor_InvalidCode
		 */
		/// Expressions
		public static final int CXCursor_FirstExpr = (int)100;
		/**
		 * \brief An expression whose specific kind is not exposed via this<br>
		 * interface.<br>
		 * * Unexposed expressions have the same operations as any other kind<br>
		 * of expression; one can extract their location information,<br>
		 * spelling, children, etc. However, the specific kind of the<br>
		 * expression is not reported.
		 */
		public static final int CXCursor_UnexposedExpr = (int)100;
		/**
		 * \brief An expression that refers to some value declaration, such<br>
		 * as a function, varible, or enumerator.
		 */
		public static final int CXCursor_DeclRefExpr = (int)101;
		/**
		 * \brief An expression that refers to a member of a struct, union,<br>
		 * class, Objective-C class, etc.
		 */
		public static final int CXCursor_MemberRefExpr = (int)102;
		/// \brief An expression that calls a function.
		public static final int CXCursor_CallExpr = (int)103;
		/**
		 * \brief An expression that sends a message to an Objective-C<br>
		 * object or class.
		 */
		public static final int CXCursor_ObjCMessageExpr = (int)104;
		/// \brief An expression that represents a block literal.
		public static final int CXCursor_BlockExpr = (int)105;
		/// \brief An integer literal.
		public static final int CXCursor_IntegerLiteral = (int)106;
		/// \brief A floating point number literal.
		public static final int CXCursor_FloatingLiteral = (int)107;
		/// \brief An imaginary number literal.
		public static final int CXCursor_ImaginaryLiteral = (int)108;
		/// \brief A string literal.
		public static final int CXCursor_StringLiteral = (int)109;
		/// \brief A character literal.
		public static final int CXCursor_CharacterLiteral = (int)110;
		/**
		 * \brief A parenthesized expression, e.g. "(1)".<br>
		 * * This AST node is only formed if full location information is requested.
		 */
		public static final int CXCursor_ParenExpr = (int)111;
		/**
		 * \brief This represents the unary-expression's (except sizeof and<br>
		 * alignof).
		 */
		public static final int CXCursor_UnaryOperator = (int)112;
		/// \brief [C99 6.5.2.1] Array Subscripting.
		public static final int CXCursor_ArraySubscriptExpr = (int)113;
		/**
		 * \brief A builtin binary operation expression such as "x + y" or<br>
		 * "x <= y".
		 */
		public static final int CXCursor_BinaryOperator = (int)114;
		/// \brief Compound assignment such as "+=".
		public static final int CXCursor_CompoundAssignOperator = (int)115;
		/// \brief The ?: ternary operator.
		public static final int CXCursor_ConditionalOperator = (int)116;
		/**
		 * \brief An explicit cast in C (C99 6.5.4) or a C-style cast in C++<br>
		 * (C++ [expr.cast]), which uses the syntax (Type)expr.<br>
		 * * For example: (int)f.
		 */
		public static final int CXCursor_CStyleCastExpr = (int)117;
		/// \brief [C99 6.5.2.5]
		public static final int CXCursor_CompoundLiteralExpr = (int)118;
		/// \brief Describes an C or C++ initializer list.
		public static final int CXCursor_InitListExpr = (int)119;
		/// \brief The GNU address of label extension, representing &&label.
		public static final int CXCursor_AddrLabelExpr = (int)120;
		/// \brief This is the GNU Statement Expression extension: ({int X=4; X;})
		public static final int CXCursor_StmtExpr = (int)121;
		/// \brief Represents a C1X generic selection.
		public static final int CXCursor_GenericSelectionExpr = (int)122;
		/**
		 * \brief Implements the GNU __null extension, which is a name for a null<br>
		 * pointer constant that has integral type (e.g., int or long) and is the same<br>
		 * size and alignment as a pointer.<br>
		 * * The __null extension is typically only used by system headers, which define<br>
		 * NULL as __null in C++ rather than using 0 (which is an integer that may not<br>
		 * match the size of a pointer).
		 */
		public static final int CXCursor_GNUNullExpr = (int)123;
		/// \brief C++'s static_cast<> expression.
		public static final int CXCursor_CXXStaticCastExpr = (int)124;
		/// \brief C++'s dynamic_cast<> expression.
		public static final int CXCursor_CXXDynamicCastExpr = (int)125;
		/// \brief C++'s reinterpret_cast<> expression.
		public static final int CXCursor_CXXReinterpretCastExpr = (int)126;
		/// \brief C++'s const_cast<> expression.
		public static final int CXCursor_CXXConstCastExpr = (int)127;
		/**
		 * \brief Represents an explicit C++ type conversion that uses "functional"<br>
		 * notion (C++ [expr.type.conv]).<br>
		 * * Example:<br>
		 * \code<br>
		 *   x = int(0.5);<br>
		 * \endcode
		 */
		public static final int CXCursor_CXXFunctionalCastExpr = (int)128;
		/// \brief A C++ typeid expression (C++ [expr.typeid]).
		public static final int CXCursor_CXXTypeidExpr = (int)129;
		/// \brief [C++ 2.13.5] C++ Boolean Literal.
		public static final int CXCursor_CXXBoolLiteralExpr = (int)130;
		/// \brief [C++0x 2.14.7] C++ Pointer Literal.
		public static final int CXCursor_CXXNullPtrLiteralExpr = (int)131;
		/// \brief Represents the "this" expression in C++
		public static final int CXCursor_CXXThisExpr = (int)132;
		/**
		 * \brief [C++ 15] C++ Throw Expression.<br>
		 * * This handles 'throw' and 'throw' assignment-expression. When<br>
		 * assignment-expression isn't present, Op will be null.
		 */
		public static final int CXCursor_CXXThrowExpr = (int)133;
		/**
		 * \brief A new expression for memory allocation and constructor calls, e.g:<br>
		 * "new CXXNewExpr(foo)".
		 */
		public static final int CXCursor_CXXNewExpr = (int)134;
		/**
		 * \brief A delete expression for memory deallocation and destructor calls,<br>
		 * e.g. "delete[] pArray".
		 */
		public static final int CXCursor_CXXDeleteExpr = (int)135;
		/// \brief A unary expression.
		public static final int CXCursor_UnaryExpr = (int)136;
		/// \brief ObjCStringLiteral, used for Objective-C string literals i.e. "foo".
		public static final int CXCursor_ObjCStringLiteral = (int)137;
		/// \brief ObjCEncodeExpr, used for in Objective-C.
		public static final int CXCursor_ObjCEncodeExpr = (int)138;
		/// \brief ObjCSelectorExpr used for in Objective-C.
		public static final int CXCursor_ObjCSelectorExpr = (int)139;
		/// \brief Objective-C's protocol expression.
		public static final int CXCursor_ObjCProtocolExpr = (int)140;
		/**
		 * \brief An Objective-C "bridged" cast expression, which casts between<br>
		 * Objective-C pointers and C pointers, transferring ownership in the process.<br>
		 * * \code<br>
		 *   NSString *str = (__bridge_transfer NSString *)CFCreateString();<br>
		 * \endcode
		 */
		public static final int CXCursor_ObjCBridgedCastExpr = (int)141;
		/**
		 * \brief Represents a C++0x pack expansion that produces a sequence of<br>
		 * expressions.<br>
		 * * A pack expansion expression contains a pattern (which itself is an<br>
		 * expression) followed by an ellipsis. For example:<br>
		 * * \code<br>
		 * template<typename F, typename ...Types><br>
		 * void forward(F f, Types &&...args) {<br>
		 *  f(static_cast<Types&&>(args)...);<br>
		 * }<br>
		 * \endcode
		 */
		public static final int CXCursor_PackExpansionExpr = (int)142;
		/**
		 * \brief Represents an expression that computes the length of a parameter<br>
		 * pack.<br>
		 * * \code<br>
		 * template<typename ...Types><br>
		 * struct count {<br>
		 *   static const unsigned value = sizeof...(Types);<br>
		 * };<br>
		 * \endcode
		 */
		public static final int CXCursor_SizeOfPackExpr = (int)143;
		/**
		 * SKIPPED:<br>
		 * <i>native declaration : line 1640</i><br>
		 * CXCursor_LastExpr = CXCursor_SizeOfPackExpr
		 */
		/// Statements
		public static final int CXCursor_FirstStmt = (int)200;
		/**
		 * \brief A statement whose specific kind is not exposed via this<br>
		 * interface.<br>
		 * * Unexposed statements have the same operations as any other kind of<br>
		 * statement; one can extract their location information, spelling,<br>
		 * children, etc. However, the specific kind of the statement is not<br>
		 * reported.
		 */
		public static final int CXCursor_UnexposedStmt = (int)200;
		/**
		 * \brief A labelled statement in a function. <br>
		 * * This cursor kind is used to describe the "start_over:" label statement in <br>
		 * the following example:<br>
		 * * \code<br>
		 *   start_over:<br>
		 *     ++counter;<br>
		 * \endcode
		 */
		public static final int CXCursor_LabelStmt = (int)201;
		/**
		 * \brief A group of statements like { stmt stmt }.<br>
		 * * This cursor kind is used to describe compound statements, e.g. function<br>
		 * bodies.
		 */
		public static final int CXCursor_CompoundStmt = (int)202;
		/// \brief A case statment.
		public static final int CXCursor_CaseStmt = (int)203;
		/// \brief A default statement.
		public static final int CXCursor_DefaultStmt = (int)204;
		/// \brief An if statement
		public static final int CXCursor_IfStmt = (int)205;
		/// \brief A switch statement.
		public static final int CXCursor_SwitchStmt = (int)206;
		/// \brief A while statement.
		public static final int CXCursor_WhileStmt = (int)207;
		/// \brief A do statement.
		public static final int CXCursor_DoStmt = (int)208;
		/// \brief A for statement.
		public static final int CXCursor_ForStmt = (int)209;
		/// \brief A goto statement.
		public static final int CXCursor_GotoStmt = (int)210;
		/// \brief An indirect goto statement.
		public static final int CXCursor_IndirectGotoStmt = (int)211;
		/// \brief A continue statement.
		public static final int CXCursor_ContinueStmt = (int)212;
		/// \brief A break statement.
		public static final int CXCursor_BreakStmt = (int)213;
		/// \brief A return statement.
		public static final int CXCursor_ReturnStmt = (int)214;
		/// \brief A GNU inline assembly statement extension.
		public static final int CXCursor_AsmStmt = (int)215;
		/// \brief Objective-C's overall @try-@catc-@finall statement.
		public static final int CXCursor_ObjCAtTryStmt = (int)216;
		/// \brief Objective-C's @catch statement.
		public static final int CXCursor_ObjCAtCatchStmt = (int)217;
		/// \brief Objective-C's @finally statement.
		public static final int CXCursor_ObjCAtFinallyStmt = (int)218;
		/// \brief Objective-C's @throw statement.
		public static final int CXCursor_ObjCAtThrowStmt = (int)219;
		/// \brief Objective-C's @synchronized statement.
		public static final int CXCursor_ObjCAtSynchronizedStmt = (int)220;
		/// \brief Objective-C's autorelease pool statement.
		public static final int CXCursor_ObjCAutoreleasePoolStmt = (int)221;
		/// \brief Objective-C's collection statement.
		public static final int CXCursor_ObjCForCollectionStmt = (int)222;
		/// \brief C++'s catch statement.
		public static final int CXCursor_CXXCatchStmt = (int)223;
		/// \brief C++'s try statement.
		public static final int CXCursor_CXXTryStmt = (int)224;
		/// \brief C++'s for (* : *) statement.
		public static final int CXCursor_CXXForRangeStmt = (int)225;
		/// \brief Windows Structured Exception Handling's try statement.
		public static final int CXCursor_SEHTryStmt = (int)226;
		/// \brief Windows Structured Exception Handling's except statement.
		public static final int CXCursor_SEHExceptStmt = (int)227;
		/// \brief Windows Structured Exception Handling's finally statement.
		public static final int CXCursor_SEHFinallyStmt = (int)228;
		/**
		 * \brief The null satement ";": C99 6.8.3p3.<br>
		 * * This cursor kind is used to describe the null statement.
		 */
		public static final int CXCursor_NullStmt = (int)230;
		/**
		 * \brief Adaptor class for mixing declarations with statements and<br>
		 * expressions.
		 */
		public static final int CXCursor_DeclStmt = (int)231;
		/**
		 * SKIPPED:<br>
		 * <i>native declaration : line 1790</i><br>
		 * CXCursor_LastStmt = CXCursor_DeclStmt
		 */
		/**
		 * \brief Cursor that represents the translation unit itself.<br>
		 * * The translation unit cursor exists primarily to act as the root<br>
		 * cursor for traversing the contents of a translation unit.
		 */
		public static final int CXCursor_TranslationUnit = (int)300;
		/// Attributes
		public static final int CXCursor_FirstAttr = (int)400;
		/**
		 * \brief An attribute whose specific kind is not exposed via this<br>
		 * interface.
		 */
		public static final int CXCursor_UnexposedAttr = (int)400;
		public static final int CXCursor_IBActionAttr = (int)401;
		public static final int CXCursor_IBOutletAttr = (int)402;
		public static final int CXCursor_IBOutletCollectionAttr = (int)403;
		public static final int CXCursor_CXXFinalAttr = (int)404;
		public static final int CXCursor_CXXOverrideAttr = (int)405;
		public static final int CXCursor_AnnotateAttr = (int)406;
		/**
		 * SKIPPED:<br>
		 * <i>native declaration : line 1814</i><br>
		 * CXCursor_LastAttr = CXCursor_AnnotateAttr
		 */
		/// Preprocessing
		public static final int CXCursor_PreprocessingDirective = (int)500;
		public static final int CXCursor_MacroDefinition = (int)501;
		public static final int CXCursor_MacroExpansion = (int)502;
		/**
		 * SKIPPED:<br>
		 * <i>native declaration : line 1820</i><br>
		 * CXCursor_MacroInstantiation = CXCursor_MacroExpansion
		 */
		public static final int CXCursor_InclusionDirective = (int)503;
		/**
		 * SKIPPED:<br>
		 * <i>native declaration : line 1822</i><br>
		 * CXCursor_FirstPreprocessing = CXCursor_PreprocessingDirective
		 */
		/**
		 * SKIPPED:<br>
		 * <i>native declaration : line 1823</i><br>
		 * CXCursor_LastPreprocessing = CXCursor_InclusionDirective
		 */
	};
	public static interface CXLinkageKind {
		/**
		 * \brief This value indicates that no linkage information is available<br>
		 * for a provided CXCursor.
		 */
		public static final int CXLinkage_Invalid = (int)0;
		/**
		 * \brief This is the linkage for variables, parameters, and so on that<br>
		 *  have automatic storage.  This covers normal (non-extern) local variables.
		 */
		public static final int CXLinkage_NoLinkage = (int)1;
		/// \brief This is the linkage for static variables and static functions.
		public static final int CXLinkage_Internal = (int)2;
		/**
		 * \brief This is the linkage for entities with external linkage that live<br>
		 * in C++ anonymous namespaces.
		 */
		public static final int CXLinkage_UniqueExternal = (int)3;
		/// \brief This is the linkage for entities with true, external linkage.
		public static final int CXLinkage_External = (int)4;
	};
	public static interface CXLanguageKind {
		public static final int CXLanguage_Invalid = (int)0;
		public static final int CXLanguage_C = (int)1;
		public static final int CXLanguage_ObjC = (int)2;
		public static final int CXLanguage_CPlusPlus = (int)3;
	};
	public static interface CXTypeKind {
		/// \brief Reprents an invalid type (e.g., where no type is available).
		public static final int CXType_Invalid = (int)0;
		/**
		 * \brief A type whose specific kind is not exposed via this<br>
		 * interface.
		 */
		public static final int CXType_Unexposed = (int)1;
		/// Builtin types
		public static final int CXType_Void = (int)2;
		public static final int CXType_Bool = (int)3;
		public static final int CXType_Char_U = (int)4;
		public static final int CXType_UChar = (int)5;
		public static final int CXType_Char16 = (int)6;
		public static final int CXType_Char32 = (int)7;
		public static final int CXType_UShort = (int)8;
		public static final int CXType_UInt = (int)9;
		public static final int CXType_ULong = (int)10;
		public static final int CXType_ULongLong = (int)11;
		public static final int CXType_UInt128 = (int)12;
		public static final int CXType_Char_S = (int)13;
		public static final int CXType_SChar = (int)14;
		public static final int CXType_WChar = (int)15;
		public static final int CXType_Short = (int)16;
		public static final int CXType_Int = (int)17;
		public static final int CXType_Long = (int)18;
		public static final int CXType_LongLong = (int)19;
		public static final int CXType_Int128 = (int)20;
		public static final int CXType_Float = (int)21;
		public static final int CXType_Double = (int)22;
		public static final int CXType_LongDouble = (int)23;
		public static final int CXType_NullPtr = (int)24;
		public static final int CXType_Overload = (int)25;
		public static final int CXType_Dependent = (int)26;
		public static final int CXType_ObjCId = (int)27;
		public static final int CXType_ObjCClass = (int)28;
		public static final int CXType_ObjCSel = (int)29;
		/**
		 * SKIPPED:<br>
		 * <i>native declaration : line 2271</i><br>
		 * CXType_FirstBuiltin = CXType_Void
		 */
		/**
		 * SKIPPED:<br>
		 * <i>native declaration : line 2272</i><br>
		 * CXType_LastBuiltin = CXType_ObjCSel
		 */
		public static final int CXType_Complex = (int)100;
		public static final int CXType_Pointer = (int)101;
		public static final int CXType_BlockPointer = (int)102;
		public static final int CXType_LValueReference = (int)103;
		public static final int CXType_RValueReference = (int)104;
		public static final int CXType_Record = (int)105;
		public static final int CXType_Enum = (int)106;
		public static final int CXType_Typedef = (int)107;
		public static final int CXType_ObjCInterface = (int)108;
		public static final int CXType_ObjCObjectPointer = (int)109;
		public static final int CXType_FunctionNoProto = (int)110;
		public static final int CXType_FunctionProto = (int)111;
		public static final int CXType_ConstantArray = (int)112;
	};
	public static interface CX_CXXAccessSpecifier {
		public static final int CX_CXXInvalidAccessSpecifier = (int)0;
		public static final int CX_CXXPublic = (int)1;
		public static final int CX_CXXProtected = (int)2;
		public static final int CX_CXXPrivate = (int)3;
	};
	
	public static interface CXChildVisitResult {
		/// \brief Terminates the cursor traversal.
		public static final int CXChildVisit_Break = (int)0;
		/**
		 * \brief Continues the cursor traversal with the next sibling of<br>
		 * the cursor just visited, without visiting its children.
		 */
		public static final int CXChildVisit_Continue = (int)1;
		/**
		 * \brief Recursively traverse the children of this cursor, using<br>
		 * the same visitor and client data.
		 */
		public static final int CXChildVisit_Recurse = (int)2;
	};
	
	public static interface CXNameRefFlags {
		/**
		 * \brief Include the nested-name-specifier, e.g. Foo:: in x.Foo::y, in the<br>
		 * range.
		 */
		public static final int CXNameRange_WantQualifier = (int)0x1;
		/**
		 * \brief Include the explicit template arguments, e.g. <int> in x.f<int>, in <br>
		 * the range.
		 */
		public static final int CXNameRange_WantTemplateArgs = (int)0x2;
		/**
		 * \brief If the name is non-contiguous, return the full spanning range.<br>
		 * * Non-contiguous names occur in Objective-C when a selector with two or more<br>
		 * parameters is used, or in C++ when using an operator:<br>
		 * \code<br>
		 * [object doSomething:here withValue:there]; // ObjC<br>
		 * return some_vector[1]; // C++<br>
		 * \endcode
		 */
		public static final int CXNameRange_WantSinglePiece = (int)0x4;
	};
	public static interface CXTokenKind {
		/// \brief A token that contains some kind of punctuation.
		public static final int CXToken_Punctuation = (int)0;
		/// \brief A language keyword.
		public static final int CXToken_Keyword = (int)1;
		/// \brief An identifier (that is not a keyword).
		public static final int CXToken_Identifier = (int)2;
		/// \brief A numeric, string, or character literal.
		public static final int CXToken_Literal = (int)3;
		/// \brief A comment.
		public static final int CXToken_Comment = (int)4;
	};
	public static interface CXCompletionChunkKind {
		/**
		 * \brief A code-completion string that describes "optional" text that<br>
		 * could be a part of the template (but is not required).<br>
		 * * The Optional chunk is the only kind of chunk that has a code-completion<br>
		 * string for its representation, which is accessible via<br>
		 * \c clang_getCompletionChunkCompletionString(). The code-completion string<br>
		 * describes an additional part of the template that is completely optional.<br>
		 * For example, optional chunks can be used to describe the placeholders for<br>
		 * arguments that match up with defaulted function parameters, e.g. given:<br>
		 * * \code<br>
		 * void f(int x, float y = 3.14, double z = 2.71828);<br>
		 * \endcode<br>
		 * * The code-completion string for this function would contain:<br>
		 *   - a TypedText chunk for "f".<br>
		 *   - a LeftParen chunk for "(".<br>
		 *   - a Placeholder chunk for "int x"<br>
		 *   - an Optional chunk containing the remaining defaulted arguments, e.g.,<br>
		 *       - a Comma chunk for ","<br>
		 *       - a Placeholder chunk for "float y"<br>
		 *       - an Optional chunk containing the last defaulted argument:<br>
		 *           - a Comma chunk for ","<br>
		 *           - a Placeholder chunk for "double z"<br>
		 *   - a RightParen chunk for ")"<br>
		 * * There are many ways to handle Optional chunks. Two simple approaches are:<br>
		 *   - Completely ignore optional chunks, in which case the template for the<br>
		 *     function "f" would only include the first parameter ("int x").<br>
		 *   - Fully expand all optional chunks, in which case the template for the<br>
		 *     function "f" would have all of the parameters.
		 */
		public static final int CXCompletionChunk_Optional = (int)0;
		/**
		 * \brief Text that a user would be expected to type to get this<br>
		 * code-completion result.<br>
		 * * There will be exactly one "typed text" chunk in a semantic string, which<br>
		 * will typically provide the spelling of a keyword or the name of a<br>
		 * declaration that could be used at the current code point. Clients are<br>
		 * expected to filter the code-completion results based on the text in this<br>
		 * chunk.
		 */
		public static final int CXCompletionChunk_TypedText = (int)1;
		/**
		 * \brief Text that should be inserted as part of a code-completion result.<br>
		 * * A "text" chunk represents text that is part of the template to be<br>
		 * inserted into user code should this particular code-completion result<br>
		 * be selected.
		 */
		public static final int CXCompletionChunk_Text = (int)2;
		/**
		 * \brief Placeholder text that should be replaced by the user.<br>
		 * * A "placeholder" chunk marks a place where the user should insert text<br>
		 * into the code-completion template. For example, placeholders might mark<br>
		 * the function parameters for a function declaration, to indicate that the<br>
		 * user should provide arguments for each of those parameters. The actual<br>
		 * text in a placeholder is a suggestion for the text to display before<br>
		 * the user replaces the placeholder with real code.
		 */
		public static final int CXCompletionChunk_Placeholder = (int)3;
		/**
		 * \brief Informative text that should be displayed but never inserted as<br>
		 * part of the template.<br>
		 * * An "informative" chunk contains annotations that can be displayed to<br>
		 * help the user decide whether a particular code-completion result is the<br>
		 * right option, but which is not part of the actual template to be inserted<br>
		 * by code completion.
		 */
		public static final int CXCompletionChunk_Informative = (int)4;
		/**
		 * \brief Text that describes the current parameter when code-completion is<br>
		 * referring to function call, message send, or template specialization.<br>
		 * * A "current parameter" chunk occurs when code-completion is providing<br>
		 * information about a parameter corresponding to the argument at the<br>
		 * code-completion point. For example, given a function<br>
		 * * \code<br>
		 * int add(int x, int y);<br>
		 * \endcode<br>
		 * * and the source code \c add(, where the code-completion point is after the<br>
		 * "(", the code-completion string will contain a "current parameter" chunk<br>
		 * for "int x", indicating that the current argument will initialize that<br>
		 * parameter. After typing further, to \c add(17, (where the code-completion<br>
		 * point is after the ","), the code-completion string will contain a<br>
		 * "current paremeter" chunk to "int y".
		 */
		public static final int CXCompletionChunk_CurrentParameter = (int)5;
		/**
		 * \brief A left parenthesis ('('), used to initiate a function call or<br>
		 * signal the beginning of a function parameter list.
		 */
		public static final int CXCompletionChunk_LeftParen = (int)6;
		/**
		 * \brief A right parenthesis (')'), used to finish a function call or<br>
		 * signal the end of a function parameter list.
		 */
		public static final int CXCompletionChunk_RightParen = (int)7;
		/// \brief A left bracket ('[').
		public static final int CXCompletionChunk_LeftBracket = (int)8;
		/// \brief A right bracket (']').
		public static final int CXCompletionChunk_RightBracket = (int)9;
		/// \brief A left brace ('{').
		public static final int CXCompletionChunk_LeftBrace = (int)10;
		/// \brief A right brace ('}').
		public static final int CXCompletionChunk_RightBrace = (int)11;
		/// \brief A left angle bracket ('<').
		public static final int CXCompletionChunk_LeftAngle = (int)12;
		/// \brief A right angle bracket ('>').
		public static final int CXCompletionChunk_RightAngle = (int)13;
		/// \brief A comma separator (',').
		public static final int CXCompletionChunk_Comma = (int)14;
		/**
		 * \brief Text that specifies the result type of a given result.<br>
		 * * This special kind of informative chunk is not meant to be inserted into<br>
		 * the text buffer. Rather, it is meant to illustrate the type that an<br>
		 * expression using the given completion string would have.
		 */
		public static final int CXCompletionChunk_ResultType = (int)15;
		/// \brief A colon (':').
		public static final int CXCompletionChunk_Colon = (int)16;
		/// \brief A semicolon (';').
		public static final int CXCompletionChunk_SemiColon = (int)17;
		/// \brief An '=' sign.
		public static final int CXCompletionChunk_Equal = (int)18;
		/// Horizontal space (' ').
		public static final int CXCompletionChunk_HorizontalSpace = (int)19;
		/**
		 * Vertical space ('\n'), after which it is generally a good idea to<br>
		 * perform indentation.
		 */
		public static final int CXCompletionChunk_VerticalSpace = (int)20;
	};
	public static interface CXCodeComplete_Flags {
		/**
		 * \brief Whether to include macros within the set of code<br>
		 * completions returned.
		 */
		public static final int CXCodeComplete_IncludeMacros = (int)0x01;
		/**
		 * \brief Whether to include code patterns for language constructs<br>
		 * within the set of code completions, e.g., for loops.
		 */
		public static final int CXCodeComplete_IncludeCodePatterns = (int)0x02;
	};
	public static interface CXCompletionContext {
		/**
		 * \brief The context for completions is unexposed, as only Leftovers results<br>
		 * should be included. (This is equivalent to having no context bits set.)
		 */
		public static final int CXCompletionContext_Unexposed = (int)0;
		/// \brief Completions for any possible type should be included in the results.
		public static final int CXCompletionContext_AnyType = (int)1 << 0;
		/**
		 * \brief Completions for any possible value (variables, function calls, etc.)<br>
		 * should be included in the results.
		 */
		public static final int CXCompletionContext_AnyValue = (int)1 << 1;
		/**
		 * \brief Completions for values that resolve to an Objective-C object should<br>
		 * be included in the results.
		 */
		public static final int CXCompletionContext_ObjCObjectValue = (int)1 << 2;
		/**
		 * \brief Completions for values that resolve to an Objective-C selector<br>
		 * should be included in the results.
		 */
		public static final int CXCompletionContext_ObjCSelectorValue = (int)1 << 3;
		/**
		 * \brief Completions for values that resolve to a C++ class type should be<br>
		 * included in the results.
		 */
		public static final int CXCompletionContext_CXXClassTypeValue = (int)1 << 4;
		/**
		 * \brief Completions for fields of the member being accessed using the dot<br>
		 * operator should be included in the results.
		 */
		public static final int CXCompletionContext_DotMemberAccess = (int)1 << 5;
		/**
		 * \brief Completions for fields of the member being accessed using the arrow<br>
		 * operator should be included in the results.
		 */
		public static final int CXCompletionContext_ArrowMemberAccess = (int)1 << 6;
		/**
		 * \brief Completions for properties of the Objective-C object being accessed<br>
		 * using the dot operator should be included in the results.
		 */
		public static final int CXCompletionContext_ObjCPropertyAccess = (int)1 << 7;
		/// \brief Completions for enum tags should be included in the results.
		public static final int CXCompletionContext_EnumTag = (int)1 << 8;
		/// \brief Completions for union tags should be included in the results.
		public static final int CXCompletionContext_UnionTag = (int)1 << 9;
		/// \brief Completions for struct tags should be included in the results.
		public static final int CXCompletionContext_StructTag = (int)1 << 10;
		/// \brief Completions for C++ class names should be included in the results.
		public static final int CXCompletionContext_ClassTag = (int)1 << 11;
		/**
		 * \brief Completions for C++ namespaces and namespace aliases should be<br>
		 * included in the results.
		 */
		public static final int CXCompletionContext_Namespace = (int)1 << 12;
		/**
		 * \brief Completions for C++ nested name specifiers should be included in<br>
		 * the results.
		 */
		public static final int CXCompletionContext_NestedNameSpecifier = (int)1 << 13;
		/**
		 * \brief Completions for Objective-C interfaces (classes) should be included<br>
		 * in the results.
		 */
		public static final int CXCompletionContext_ObjCInterface = (int)1 << 14;
		/**
		 * \brief Completions for Objective-C protocols should be included in<br>
		 * the results.
		 */
		public static final int CXCompletionContext_ObjCProtocol = (int)1 << 15;
		/**
		 * \brief Completions for Objective-C categories should be included in<br>
		 * the results.
		 */
		public static final int CXCompletionContext_ObjCCategory = (int)1 << 16;
		/**
		 * \brief Completions for Objective-C instance messages should be included<br>
		 * in the results.
		 */
		public static final int CXCompletionContext_ObjCInstanceMessage = (int)1 << 17;
		/**
		 * \brief Completions for Objective-C class messages should be included in<br>
		 * the results.
		 */
		public static final int CXCompletionContext_ObjCClassMessage = (int)1 << 18;
		/**
		 * \brief Completions for Objective-C selector names should be included in<br>
		 * the results.
		 */
		public static final int CXCompletionContext_ObjCSelectorName = (int)1 << 19;
		/**
		 * \brief Completions for preprocessor macro names should be included in<br>
		 * the results.
		 */
		public static final int CXCompletionContext_MacroName = (int)1 << 20;
		/// \brief Natural language completions should be included in the results.
		public static final int CXCompletionContext_NaturalLanguage = (int)1 << 21;
		/// \brief The current context is unknown, so set all contexts.
		public static final int CXCompletionContext_Unknown = (int)((1 << 22) - 1);
	};
	
	public static interface CXVisitorResult {
		public static final int CXVisit_Break = (int)0;
		public static final int CXVisit_Continue = (int)1;
	};
	
	public static class CXUnsavedFile extends Structure {
		/**
		 * \brief The file whose contents have not yet been saved.<br>
		 * * This file must already exist in the file system.
		 */
		public Pointer Filename;
		/// \brief A buffer containing the unsaved contents of this file.
		public Pointer Contents;
		/// \brief The length of the unsaved contents of this buffer.
		public NativeLong Length;
		public CXUnsavedFile() {
			super();
			initFieldOrder();
		}
		protected void initFieldOrder() {
			setFieldOrder(new String[]{"Filename", "Contents", "Length"});
		}
		public CXUnsavedFile(Pointer Filename, Pointer Contents, NativeLong Length) {
			super();
			this.Filename = Filename;
			this.Contents = Contents;
			this.Length = Length;
			initFieldOrder();
		}
		public static class ByReference extends CXUnsavedFile implements Structure.ByReference {
			
		};
		public static class ByValue extends CXUnsavedFile implements Structure.ByValue {
			
		};
	};
	public static class CXString extends Structure {
		public Pointer data;
		public int private_flags;
		public CXString() {
			super();
			initFieldOrder();
		}
		protected void initFieldOrder() {
			setFieldOrder(new String[]{"data", "private_flags"});
		}
		public CXString(Pointer data, int private_flags) {
			super();
			this.data = data;
			this.private_flags = private_flags;
			initFieldOrder();
		}
		public static class ByReference extends CXString implements Structure.ByReference {
			
		};
		public static class ByValue extends CXString implements Structure.ByValue {
			
		};
	};
	public static class CXSourceLocation extends Structure {
		public Pointer[] ptr_data = new Pointer[(2)];
		public int int_data;
		public CXSourceLocation() {
			super();
			initFieldOrder();
		}
		protected void initFieldOrder() {
			setFieldOrder(new String[]{"ptr_data", "int_data"});
		}
		public CXSourceLocation(Pointer ptr_data[], int int_data) {
			super();
			if (ptr_data.length != this.ptr_data.length) 
				throw new IllegalArgumentException("Wrong array size !");
			this.ptr_data = ptr_data;
			this.int_data = int_data;
			initFieldOrder();
		}
		public static class ByReference extends CXSourceLocation implements Structure.ByReference {
			
		};
		public static class ByValue extends CXSourceLocation implements Structure.ByValue {
			
		};
	};
	public static class CXSourceRange extends Structure {
		public Pointer[] ptr_data = new Pointer[(2)];
		public int begin_int_data;
		public int end_int_data;
		public CXSourceRange() {
			super();
			initFieldOrder();
		}
		protected void initFieldOrder() {
			setFieldOrder(new String[]{"ptr_data", "begin_int_data", "end_int_data"});
		}
		public CXSourceRange(Pointer ptr_data[], int begin_int_data, int end_int_data) {
			super();
			if (ptr_data.length != this.ptr_data.length) 
				throw new IllegalArgumentException("Wrong array size !");
			this.ptr_data = ptr_data;
			this.begin_int_data = begin_int_data;
			this.end_int_data = end_int_data;
			initFieldOrder();
		}
		public static class ByReference extends CXSourceRange implements Structure.ByReference {
			
		};
		public static class ByValue extends CXSourceRange implements Structure.ByValue {
			
		};
	};
	public static class CXTUResourceUsageEntry extends Structure {
		/**
		 * \brief The memory usage category.<br>
		 * @see CXTUResourceUsageKind
		 */
		public int kind;
		/**
		 * \brief Amount of resources used. <br>
		 * The units will depend on the resource kind.
		 */
		public NativeLong amount;
		public CXTUResourceUsageEntry() {
			super();
			initFieldOrder();
		}
		protected void initFieldOrder() {
			setFieldOrder(new String[]{"kind", "amount"});
		}
		public CXTUResourceUsageEntry(int kind, NativeLong amount) {
			super();
			this.kind = kind;
			this.amount = amount;
			initFieldOrder();
		}
		public static class ByReference extends CXTUResourceUsageEntry implements Structure.ByReference {
			
		};
		public static class ByValue extends CXTUResourceUsageEntry implements Structure.ByValue {
			
		};
	};
	public static class CXTUResourceUsage extends Structure {
		/// \brief Private data member, used for queries.
		public Pointer data;
		/// \brief The number of entries in the 'entries' array.
		public int numEntries;
		/**
		 * \brief An array of key-value pairs, representing the breakdown of memory<br>
		 * usage.
		 */
		public ClangLibrary.CXTUResourceUsageEntry.ByReference entries;
		public CXTUResourceUsage() {
			super();
			initFieldOrder();
		}
		protected void initFieldOrder() {
			setFieldOrder(new String[]{"data", "numEntries", "entries"});
		}
		public CXTUResourceUsage(Pointer data, int numEntries, ClangLibrary.CXTUResourceUsageEntry.ByReference entries) {
			super();
			this.data = data;
			this.numEntries = numEntries;
			this.entries = entries;
			initFieldOrder();
		}
		public static class ByReference extends CXTUResourceUsage implements Structure.ByReference {
			
		};
		public static class ByValue extends CXTUResourceUsage implements Structure.ByValue {
			
		};
	};
	public static class CXCursor extends Structure {
		/// @see CXCursorKind
		public int kind;
		public int xdata;
		public Pointer[] data = new Pointer[(3)];
		public CXCursor() {
			super();
			initFieldOrder();
		}
		protected void initFieldOrder() {
			setFieldOrder(new String[]{"kind", "xdata", "data"});
		}
		public CXCursor(int kind, int xdata, Pointer data[]) {
			super();
			this.kind = kind;
			this.xdata = xdata;
			if (data.length != this.data.length) 
				throw new IllegalArgumentException("Wrong array size !");
			this.data = data;
			initFieldOrder();
		}
		public static class ByReference extends CXCursor implements Structure.ByReference {
			
		};
		public static class ByValue extends CXCursor implements Structure.ByValue {
			
		};
	};
	public static class CXType extends Structure {
		/// @see CXTypeKind
		public int kind;
		public Pointer[] data = new Pointer[(2)];
		public CXType() {
			super();
			initFieldOrder();
		}
		protected void initFieldOrder() {
			setFieldOrder(new String[]{"kind", "data"});
		}
		public CXType(int kind, Pointer data[]) {
			super();
			this.kind = kind;
			if (data.length != this.data.length) 
				throw new IllegalArgumentException("Wrong array size !");
			this.data = data;
			initFieldOrder();
		}
		public static class ByReference extends CXType implements Structure.ByReference {
			
		};
		public static class ByValue extends CXType implements Structure.ByValue {
			
		};
	};
	public static class CXToken extends Structure {
		public int[] int_data = new int[(4)];
		public Pointer ptr_data;
		public CXToken() {
			super();
			initFieldOrder();
		}
		protected void initFieldOrder() {
			setFieldOrder(new String[]{"int_data", "ptr_data"});
		}
		public CXToken(int int_data[], Pointer ptr_data) {
			super();
			if (int_data.length != this.int_data.length) 
				throw new IllegalArgumentException("Wrong array size !");
			this.int_data = int_data;
			this.ptr_data = ptr_data;
			initFieldOrder();
		}
		public static class ByReference extends CXToken implements Structure.ByReference {
			
		};
		public static class ByValue extends CXToken implements Structure.ByValue {
			
		};
	};
	public static class CXCompletionResult extends Structure {
		/**
		 * \brief The kind of entity that this completion refers to.<br>
		 * * The cursor kind will be a macro, keyword, or a declaration (one of the<br>
		 * *Decl cursor kinds), describing the entity that the completion is<br>
		 * referring to.<br>
		 * * \todo In the future, we would like to provide a full cursor, to allow<br>
		 * the client to extract additional information from declaration.<br>
		 * @see CXCursorKind
		 */
		public int CursorKind;
		/**
		 * \brief The code-completion string that describes how to insert this<br>
		 * code-completion result into the editing buffer.
		 */
		public Pointer CompletionString;
		public CXCompletionResult() {
			super();
			initFieldOrder();
		}
		protected void initFieldOrder() {
			setFieldOrder(new String[]{"CursorKind", "CompletionString"});
		}
		public CXCompletionResult(int CursorKind, Pointer CompletionString) {
			super();
			this.CursorKind = CursorKind;
			this.CompletionString = CompletionString;
			initFieldOrder();
		}
		public static class ByReference extends CXCompletionResult implements Structure.ByReference {
			
		};
		public static class ByValue extends CXCompletionResult implements Structure.ByValue {
			
		};
	};
	public static class CXCodeCompleteResults extends Structure {
		/// \brief The code-completion results.
		public ClangLibrary.CXCompletionResult.ByReference Results;
		/**
		 * \brief The number of code-completion results stored in the<br>
		 * \c Results array.
		 */
		public int NumResults;
		public CXCodeCompleteResults() {
			super();
			initFieldOrder();
		}
		protected void initFieldOrder() {
			setFieldOrder(new String[]{"Results", "NumResults"});
		}
		public CXCodeCompleteResults(ClangLibrary.CXCompletionResult.ByReference Results, int NumResults) {
			super();
			this.Results = Results;
			this.NumResults = NumResults;
			initFieldOrder();
		}
		public static class ByReference extends CXCodeCompleteResults implements Structure.ByReference {
			
		};
		public static class ByValue extends CXCodeCompleteResults implements Structure.ByValue {
			
		};
	};
	public static class CXCursorAndRangeVisitor extends Structure {
		public Pointer context;
		public ClangLibrary.CXCursorAndRangeVisitor.visit_callback visit;
		public interface visit_callback extends Callback {
			/**
			 * @see CXVisitorResult
			 */int apply(Pointer context, ClangLibrary.CXCursor.ByValue CXCursor1, ClangLibrary.CXSourceRange.ByValue CXSourceRange1);
		};
		public CXCursorAndRangeVisitor() {
			super();
			initFieldOrder();
		}
		protected void initFieldOrder() {
			setFieldOrder(new String[]{"context", "visit"});
		}
		public CXCursorAndRangeVisitor(Pointer context, ClangLibrary.CXCursorAndRangeVisitor.visit_callback visit) {
			super();
			this.context = context;
			this.visit = visit;
			initFieldOrder();
		}
		public static class ByReference extends CXCursorAndRangeVisitor implements Structure.ByReference {
			
		};
		public static class ByValue extends CXCursorAndRangeVisitor implements Structure.ByValue {
			
		};
	};
	
	public interface CXCursorVisitor extends Callback {
		/**
		 * @see CXChildVisitResult
		 */int apply(ClangLibrary.CXCursor.ByValue cursor, ClangLibrary.CXCursor.ByValue parent, Pointer client_data);
	};
	public interface CXInclusionVisitor extends Callback {
		void apply(Pointer included_file, ClangLibrary.CXSourceLocation inclusion_stack, int include_len, Pointer client_data);
	};
	
	public interface clang_executeOnThread_arg1_fn_callback extends Callback {
		void apply(Pointer voidPtr1);
	};
	
	//public static native String clang_getCString(ClangLibrary.CXString.ByValue string);
	//public static native void clang_disposeString(ClangLibrary.CXString.ByValue string);
	
	public static native Pointer clang_createIndex(int excludeDeclarationsFromPCH, int displayDiagnostics);
	public static native void clang_disposeIndex(Pointer index);
	
	public static native String clang_getFileName(Pointer SFile);
	public static native ClangLibrary.time_t clang_getFileTime(Pointer SFile);
	public static native int clang_isFileMultipleIncludeGuarded(ClangLibrary.CXTranslationUnitImpl tu, Pointer file);
	@Deprecated 
	public static native Pointer clang_getFile(ClangLibrary.CXTranslationUnitImpl tu, Pointer file_name);
	public static native Pointer clang_getFile(ClangLibrary.CXTranslationUnitImpl tu, String file_name);
	
	public static native ClangLibrary.CXSourceLocation.ByValue clang_getNullLocation();
	public static native int clang_equalLocations(ClangLibrary.CXSourceLocation.ByValue loc1, ClangLibrary.CXSourceLocation.ByValue loc2);
	public static native ClangLibrary.CXSourceLocation.ByValue clang_getLocation(ClangLibrary.CXTranslationUnitImpl tu, Pointer file, int line, int column);
	public static native ClangLibrary.CXSourceLocation.ByValue clang_getLocationForOffset(ClangLibrary.CXTranslationUnitImpl tu, Pointer file, int offset);
	public static native ClangLibrary.CXSourceRange.ByValue clang_getNullRange();
	public static native ClangLibrary.CXSourceRange.ByValue clang_getRange(ClangLibrary.CXSourceLocation.ByValue begin, ClangLibrary.CXSourceLocation.ByValue end);
	public static native int clang_equalRanges(ClangLibrary.CXSourceRange.ByValue range1, ClangLibrary.CXSourceRange.ByValue range2);
	public static native int clang_Range_isNull(ClangLibrary.CXSourceRange.ByValue range);
//	@Deprecated 
//	public static native void clang_getExpansionLocation(ClangLibrary.CXSourceLocation.ByValue location, PointerByReference file, IntByReference line, IntByReference column, IntByReference offset);
//	public static native void clang_getExpansionLocation(ClangLibrary.CXSourceLocation.ByValue location, PointerByReference file, IntBuffer line, IntBuffer column, IntBuffer offset);
	@Deprecated 
	public static native void clang_getPresumedLocation(ClangLibrary.CXSourceLocation.ByValue location, String filename, IntByReference line, IntByReference column);
	public static native void clang_getPresumedLocation(ClangLibrary.CXSourceLocation.ByValue location, String filename, IntBuffer line, IntBuffer column);
	@Deprecated 
	public static native void clang_getInstantiationLocation(ClangLibrary.CXSourceLocation.ByValue location, PointerByReference file, IntByReference line, IntByReference column, IntByReference offset);
	public static native void clang_getInstantiationLocation(ClangLibrary.CXSourceLocation.ByValue location, PointerByReference file, IntBuffer line, IntBuffer column, IntBuffer offset);
	@Deprecated 
	public static native void clang_getSpellingLocation(ClangLibrary.CXSourceLocation.ByValue location, PointerByReference file, IntByReference line, IntByReference column, IntByReference offset);
	public static native void clang_getSpellingLocation(ClangLibrary.CXSourceLocation.ByValue location, PointerByReference file, IntBuffer line, IntBuffer column, IntBuffer offset);
	public static native ClangLibrary.CXSourceLocation.ByValue clang_getRangeStart(ClangLibrary.CXSourceRange.ByValue range);
	public static native ClangLibrary.CXSourceLocation.ByValue clang_getRangeEnd(ClangLibrary.CXSourceRange.ByValue range);
	public static native int clang_getNumDiagnostics(ClangLibrary.CXTranslationUnitImpl Unit);
	public static native Pointer clang_getDiagnostic(ClangLibrary.CXTranslationUnitImpl Unit, int Index);
	public static native void clang_disposeDiagnostic(Pointer Diagnostic);
	public static native String clang_formatDiagnostic(Pointer Diagnostic, int Options);
	public static native int clang_defaultDiagnosticDisplayOptions();
	public static native /**
	 * @see CXDiagnosticSeverity
	 */int clang_getDiagnosticSeverity(Pointer CXDiagnostic1);
	public static native ClangLibrary.CXSourceLocation.ByValue clang_getDiagnosticLocation(Pointer CXDiagnostic1);
	public static native String clang_getDiagnosticSpelling(Pointer CXDiagnostic1);
	public static native String clang_getDiagnosticOption(Pointer Diag, ClangLibrary.CXString Disable);
	public static native int clang_getDiagnosticCategory(Pointer CXDiagnostic1);
	public static native String clang_getDiagnosticCategoryName(int Category);
	public static native int clang_getDiagnosticNumRanges(Pointer CXDiagnostic1);
	public static native ClangLibrary.CXSourceRange.ByValue clang_getDiagnosticRange(Pointer Diagnostic, int Range);
	public static native int clang_getDiagnosticNumFixIts(Pointer Diagnostic);
	public static native String clang_getDiagnosticFixIt(Pointer Diagnostic, int FixIt, ClangLibrary.CXSourceRange ReplacementRange);
	
	public static native String clang_getTranslationUnitSpelling(ClangLibrary.CXTranslationUnitImpl CTUnit);
	
	@Deprecated 	
	public static native ClangLibrary.CXTranslationUnitImpl clang_createTranslationUnitFromSourceFile(
			Pointer CIdx,
			String source_filename, 
			int num_clang_command_line_args, 
			Pointer clang_command_line_args, 
			int num_unsaved_files,
			Pointer unsaved_files);
	
//	public static native ClangLibrary.CXTranslationUnitImpl 
//	clang_createTranslationUnitFromSourceFile(
//			Pointer CIdx,
//			String source_filename, 
//			int num_clang_command_line_args,
//			byte[] clang_command_line_args[], 
//			int num_unsaved_files, 
//			ClangLibrary.CXUnsavedFile unsaved_files);
	
	@Deprecated 
	public static native ClangLibrary.CXTranslationUnitImpl clang_createTranslationUnit(Pointer CXIndex1, Pointer ast_filename);
	public static native ClangLibrary.CXTranslationUnitImpl clang_createTranslationUnit(Pointer CXIndex1, String ast_filename);
	public static native int clang_defaultEditingTranslationUnitOptions();
	@Deprecated 
	public static native ClangLibrary.CXTranslationUnitImpl clang_parseTranslationUnit(Pointer CIdx, Pointer source_filename, PointerByReference command_line_args, int num_command_line_args, ClangLibrary.CXUnsavedFile unsaved_files, int num_unsaved_files, int options);
//	public static native ClangLibrary.CXTranslationUnitImpl 
//	clang_parseTranslationUnit(Pointer CIdx, String source_filename, String command_line_args[], int num_command_line_args, ClangLibrary.CXUnsavedFile unsaved_files, int num_unsaved_files, int options);
	public static native int clang_defaultSaveOptions(ClangLibrary.CXTranslationUnitImpl TU);
	@Deprecated 
	public static native int clang_saveTranslationUnit(ClangLibrary.CXTranslationUnitImpl TU, Pointer FileName, int options);
	public static native int clang_saveTranslationUnit(ClangLibrary.CXTranslationUnitImpl TU, String FileName, int options);
	public static native void clang_disposeTranslationUnit(ClangLibrary.CXTranslationUnitImpl CXTranslationUnit1);
	public static native int clang_defaultReparseOptions(ClangLibrary.CXTranslationUnitImpl TU);
	public static native int clang_reparseTranslationUnit(ClangLibrary.CXTranslationUnitImpl TU, int num_unsaved_files, ClangLibrary.CXUnsavedFile unsaved_files, int options);
	
	public static native Pointer clang_getTUResourceUsageName(int kind);
	public static native ClangLibrary.CXTUResourceUsage.ByValue clang_getCXTUResourceUsage(ClangLibrary.CXTranslationUnitImpl TU);
	public static native void clang_disposeCXTUResourceUsage(ClangLibrary.CXTUResourceUsage.ByValue usage);
	
	public static native ClangLibrary.CXCursor.ByValue clang_getNullCursor();
	public static native ClangLibrary.CXCursor.ByValue clang_getTranslationUnitCursor(ClangLibrary.CXTranslationUnitImpl CXTranslationUnit1);
	public static native int clang_equalCursors(ClangLibrary.CXCursor.ByValue CXCursor1, ClangLibrary.CXCursor.ByValue CXCursor2);
	public static native int clang_Cursor_isNull(ClangLibrary.CXCursor.ByValue CXCursor1);
	public static native int clang_hashCursor(ClangLibrary.CXCursor.ByValue CXCursor1);
	public static native /**
	 * @see CXCursorKind
	 */int clang_getCursorKind(ClangLibrary.CXCursor.ByValue CXCursor1);
	public static native int clang_isDeclaration(int arg1);
	public static native int clang_isReference(int arg1);
	public static native int clang_isExpression(int arg1);
	public static native int clang_isStatement(int arg1);
	public static native int clang_isAttribute(int arg1);
	public static native int clang_isInvalid(int arg1);
	public static native int clang_isTranslationUnit(int arg1);
	public static native int clang_isPreprocessing(int arg1);
	public static native int clang_isUnexposed(int arg1);
	public static native /**
	 * @see CXLinkageKind
	 */int clang_getCursorLinkage(ClangLibrary.CXCursor.ByValue cursor);
	public static native /**
	 * @see CXAvailabilityKind
	 */int clang_getCursorAvailability(ClangLibrary.CXCursor.ByValue cursor);
	public static native /**
	 * @see CXLanguageKind
	 */int clang_getCursorLanguage(ClangLibrary.CXCursor.ByValue cursor);
	public static native ClangLibrary.CXTranslationUnitImpl clang_Cursor_getTranslationUnit(ClangLibrary.CXCursor.ByValue CXCursor1);
	public static native ClangLibrary.CXCursorSetImpl clang_createCXCursorSet();
	public static native void clang_disposeCXCursorSet(ClangLibrary.CXCursorSetImpl cset);
	public static native int clang_CXCursorSet_contains(ClangLibrary.CXCursorSetImpl cset, ClangLibrary.CXCursor.ByValue cursor);
	public static native int clang_CXCursorSet_insert(ClangLibrary.CXCursorSetImpl cset, ClangLibrary.CXCursor.ByValue cursor);
	public static native ClangLibrary.CXCursor.ByValue clang_getCursorSemanticParent(ClangLibrary.CXCursor.ByValue cursor);
	public static native ClangLibrary.CXCursor.ByValue clang_getCursorLexicalParent(ClangLibrary.CXCursor.ByValue cursor);
	@Deprecated 
	public static native void clang_getOverriddenCursors(ClangLibrary.CXCursor.ByValue cursor, PointerByReference overridden, IntByReference num_overridden);
	//public static native void clang_getOverriddenCursors(ClangLibrary.CXCursor.ByValue cursor, ClangLibrary.CXCursor.ByReference overridden[], IntBuffer num_overridden);
	//public static native void clang_getOverriddenCursors(ClangLibrary.CXCursor.ByValue cursor, ClangLibrary.CXCursor.ByReference overridden[], IntByReference num_overridden);
	public static native void clang_disposeOverriddenCursors(ClangLibrary.CXCursor overridden);
	public static native Pointer clang_getIncludedFile(ClangLibrary.CXCursor.ByValue cursor);
	public static native ClangLibrary.CXCursor.ByValue clang_getCursor(ClangLibrary.CXTranslationUnitImpl CXTranslationUnit1, ClangLibrary.CXSourceLocation.ByValue CXSourceLocation1);
	public static native ClangLibrary.CXSourceLocation.ByValue clang_getCursorLocation(ClangLibrary.CXCursor.ByValue CXCursor1);
	public static native ClangLibrary.CXSourceRange.ByValue clang_getCursorExtent(ClangLibrary.CXCursor.ByValue CXCursor1);
	public static native ClangLibrary.CXType.ByValue clang_getCursorType(ClangLibrary.CXCursor.ByValue C);
	public static native int clang_equalTypes(ClangLibrary.CXType.ByValue A, ClangLibrary.CXType.ByValue B);
	public static native ClangLibrary.CXType.ByValue clang_getCanonicalType(ClangLibrary.CXType.ByValue T);
	public static native int clang_isConstQualifiedType(ClangLibrary.CXType.ByValue T);
	public static native int clang_isVolatileQualifiedType(ClangLibrary.CXType.ByValue T);
	public static native int clang_isRestrictQualifiedType(ClangLibrary.CXType.ByValue T);
	public static native ClangLibrary.CXType.ByValue clang_getPointeeType(ClangLibrary.CXType.ByValue T);
	public static native ClangLibrary.CXCursor.ByValue clang_getTypeDeclaration(ClangLibrary.CXType.ByValue T);
	public static native String clang_getDeclObjCTypeEncoding(ClangLibrary.CXCursor.ByValue C);
	public static native String clang_getTypeKindSpelling(int K);
	public static native ClangLibrary.CXType.ByValue clang_getResultType(ClangLibrary.CXType.ByValue T);
	public static native ClangLibrary.CXType.ByValue clang_getCursorResultType(ClangLibrary.CXCursor.ByValue C);
	public static native int clang_isPODType(ClangLibrary.CXType.ByValue T);
	public static native ClangLibrary.CXType.ByValue clang_getArrayElementType(ClangLibrary.CXType.ByValue T);
	public static native NativeLong clang_getArraySize(ClangLibrary.CXType.ByValue T);
	public static native int clang_isVirtualBase(ClangLibrary.CXCursor.ByValue CXCursor1);
	public static native /**
	 * @see CX_CXXAccessSpecifier
	 */int clang_getCXXAccessSpecifier(ClangLibrary.CXCursor.ByValue CXCursor1);
	public static native int clang_getNumOverloadedDecls(ClangLibrary.CXCursor.ByValue cursor);
	public static native ClangLibrary.CXCursor.ByValue clang_getOverloadedDecl(ClangLibrary.CXCursor.ByValue cursor, int index);
	public static native ClangLibrary.CXType.ByValue clang_getIBOutletCollectionType(ClangLibrary.CXCursor.ByValue CXCursor1);
	public static native int clang_visitChildren(ClangLibrary.CXCursor.ByValue parent, ClangLibrary.CXCursorVisitor visitor, Pointer client_data);
	public static native String clang_getCursorUSR(ClangLibrary.CXCursor.ByValue CXCursor1);
	@Deprecated 
	public static native String clang_constructUSR_ObjCClass(Pointer class_name);
	public static native String clang_constructUSR_ObjCClass(String class_name);
	@Deprecated 
	public static native String clang_constructUSR_ObjCCategory(Pointer class_name, Pointer category_name);
	public static native String clang_constructUSR_ObjCCategory(String class_name, String category_name);
	@Deprecated 
	public static native String clang_constructUSR_ObjCProtocol(Pointer protocol_name);
	public static native String clang_constructUSR_ObjCProtocol(String protocol_name);
	@Deprecated 
	public static native String clang_constructUSR_ObjCIvar(Pointer name, String classUSR);
	public static native String clang_constructUSR_ObjCIvar(String name, String classUSR);
	@Deprecated 
	public static native String clang_constructUSR_ObjCMethod(Pointer name, int isInstanceMethod, String classUSR);
	public static native String clang_constructUSR_ObjCMethod(String name, int isInstanceMethod, String classUSR);
	@Deprecated 
	public static native String clang_constructUSR_ObjCProperty(Pointer property, String classUSR);
	public static native String clang_constructUSR_ObjCProperty(String property, String classUSR);
	public static native String clang_getCursorSpelling(ClangLibrary.CXCursor.ByValue CXCursor1);
	public static native String clang_getCursorDisplayName(ClangLibrary.CXCursor.ByValue CXCursor1);
	public static native ClangLibrary.CXCursor.ByValue clang_getCursorReferenced(ClangLibrary.CXCursor.ByValue CXCursor1);
	public static native ClangLibrary.CXCursor.ByValue clang_getCursorDefinition(ClangLibrary.CXCursor.ByValue CXCursor1);
	public static native int clang_isCursorDefinition(ClangLibrary.CXCursor.ByValue CXCursor1);
	public static native ClangLibrary.CXCursor.ByValue clang_getCanonicalCursor(ClangLibrary.CXCursor.ByValue CXCursor1);
	public static native int clang_CXXMethod_isStatic(ClangLibrary.CXCursor.ByValue C);
	public static native int clang_CXXMethod_isVirtual(ClangLibrary.CXCursor.ByValue C);
	public static native /**
	 * @see CXCursorKind
	 */int clang_getTemplateCursorKind(ClangLibrary.CXCursor.ByValue C);
	public static native ClangLibrary.CXCursor.ByValue clang_getSpecializedCursorTemplate(ClangLibrary.CXCursor.ByValue C);
	public static native ClangLibrary.CXSourceRange.ByValue clang_getCursorReferenceNameRange(ClangLibrary.CXCursor.ByValue C, int NameFlags, int PieceIndex);
	public static native int clang_getTokenKind(ClangLibrary.CXToken.ByValue CXToken1);
	public static native String clang_getTokenSpelling(ClangLibrary.CXTranslationUnitImpl CXTranslationUnit1, ClangLibrary.CXToken.ByValue CXToken1);
	public static native ClangLibrary.CXSourceLocation.ByValue clang_getTokenLocation(ClangLibrary.CXTranslationUnitImpl CXTranslationUnit1, ClangLibrary.CXToken.ByValue CXToken1);
	public static native ClangLibrary.CXSourceRange.ByValue clang_getTokenExtent(ClangLibrary.CXTranslationUnitImpl CXTranslationUnit1, ClangLibrary.CXToken.ByValue CXToken1);
	@Deprecated 
	public static native void clang_tokenize(ClangLibrary.CXTranslationUnitImpl TU, ClangLibrary.CXSourceRange.ByValue Range, PointerByReference Tokens, IntByReference NumTokens);
	//public static native void clang_tokenize(ClangLibrary.CXTranslationUnitImpl TU, ClangLibrary.CXSourceRange.ByValue Range, ClangLibrary.CXToken.ByReference Tokens[], IntBuffer NumTokens);
	//public static native void clang_tokenize(ClangLibrary.CXTranslationUnitImpl TU, ClangLibrary.CXSourceRange.ByValue Range, ClangLibrary.CXToken.ByReference Tokens[], IntByReference NumTokens);
	public static native void clang_annotateTokens(ClangLibrary.CXTranslationUnitImpl TU, ClangLibrary.CXToken Tokens, int NumTokens, ClangLibrary.CXCursor Cursors);
	public static native void clang_disposeTokens(ClangLibrary.CXTranslationUnitImpl TU, ClangLibrary.CXToken Tokens, int NumTokens);
	public static native String clang_getCursorKindSpelling(int Kind);
	@Deprecated 
	public static native void clang_getDefinitionSpellingAndExtent(ClangLibrary.CXCursor.ByValue CXCursor1, PointerByReference startBuf, PointerByReference endBuf, IntByReference startLine, IntByReference startColumn, IntByReference endLine, IntByReference endColumn);
	//public static native void clang_getDefinitionSpellingAndExtent(ClangLibrary.CXCursor.ByValue CXCursor1, String startBuf[], String endBuf[], IntBuffer startLine, IntBuffer startColumn, IntBuffer endLine, IntBuffer endColumn);
	public static native void clang_enableStackTraces();
	public static native void clang_executeOnThread(ClangLibrary.clang_executeOnThread_arg1_fn_callback arg1, Pointer user_data, int stack_size);
	public static native /**
	 * @see CXCompletionChunkKind
	 */int clang_getCompletionChunkKind(Pointer completion_string, int chunk_number);
	public static native String clang_getCompletionChunkText(Pointer completion_string, int chunk_number);
	public static native Pointer clang_getCompletionChunkCompletionString(Pointer completion_string, int chunk_number);
	public static native int clang_getNumCompletionChunks(Pointer completion_string);
	public static native int clang_getCompletionPriority(Pointer completion_string);
	public static native /**
	 * @see CXAvailabilityKind
	 */int clang_getCompletionAvailability(Pointer completion_string);
	public static native int clang_getCompletionNumAnnotations(Pointer completion_string);
	public static native ClangLibrary.CXString.ByValue clang_getCompletionAnnotation(Pointer completion_string, int annotation_number);
	public static native Pointer clang_getCursorCompletionString(ClangLibrary.CXCursor.ByValue cursor);
	public static native int clang_defaultCodeCompleteOptions();
	@Deprecated 
	public static native ClangLibrary.CXCodeCompleteResults clang_codeCompleteAt(ClangLibrary.CXTranslationUnitImpl TU, Pointer complete_filename, int complete_line, int complete_column, ClangLibrary.CXUnsavedFile unsaved_files, int num_unsaved_files, int options);
	public static native ClangLibrary.CXCodeCompleteResults clang_codeCompleteAt(ClangLibrary.CXTranslationUnitImpl TU, String complete_filename, int complete_line, int complete_column, ClangLibrary.CXUnsavedFile unsaved_files, int num_unsaved_files, int options);
	public static native void clang_sortCodeCompletionResults(ClangLibrary.CXCompletionResult Results, int NumResults);
	public static native void clang_disposeCodeCompleteResults(ClangLibrary.CXCodeCompleteResults Results);
	public static native int clang_codeCompleteGetNumDiagnostics(ClangLibrary.CXCodeCompleteResults Results);
	public static native Pointer clang_codeCompleteGetDiagnostic(ClangLibrary.CXCodeCompleteResults Results, int Index);
	public static native NativeLong clang_codeCompleteGetContexts(ClangLibrary.CXCodeCompleteResults Results);
	@Deprecated 
	public static native /**
	 * @see CXCursorKind
	 */int clang_codeCompleteGetContainerKind(ClangLibrary.CXCodeCompleteResults Results, IntByReference IsIncomplete);
	public static native /**
	 * @see CXCursorKind
	 */int clang_codeCompleteGetContainerKind(ClangLibrary.CXCodeCompleteResults Results, IntBuffer IsIncomplete);
	public static native ClangLibrary.CXString.ByValue clang_codeCompleteGetContainerUSR(ClangLibrary.CXCodeCompleteResults Results);
	public static native ClangLibrary.CXString.ByValue clang_codeCompleteGetObjCSelector(ClangLibrary.CXCodeCompleteResults Results);
	//public static native ClangLibrary.CXString.ByValue clang_getClangVersion();
	public static native String clang_getClangVersion();
	
	public static native void clang_toggleCrashRecovery(int isEnabled);
	public static native void clang_getInclusions(ClangLibrary.CXTranslationUnitImpl tu, ClangLibrary.CXInclusionVisitor visitor, Pointer client_data);
	@Deprecated 
	public static native Pointer clang_getRemappings(Pointer path);
	public static native Pointer clang_getRemappings(String path);
	public static native int clang_remap_getNumFiles(Pointer CXRemapping1);
	public static native void clang_remap_getFilenames(Pointer CXRemapping1, int index, ClangLibrary.CXString original, ClangLibrary.CXString transformed);
	public static native void clang_remap_dispose(Pointer CXRemapping1);
	public static native void clang_findReferencesInFile(ClangLibrary.CXCursor.ByValue cursor, Pointer file, ClangLibrary.CXCursorAndRangeVisitor.ByValue visitor);
	
	/// Pointer to unknown (opaque) type
	public static class CXCursorSetImpl extends PointerType {
		public CXCursorSetImpl(Pointer address) {
			super(address);
		}
		public CXCursorSetImpl() {
			super();
		}
	};
	/// Pointer to unknown (opaque) type
	public static class CXTranslationUnitImpl extends PointerType {
		public CXTranslationUnitImpl(Pointer address) {
			super(address);
		}
		public CXTranslationUnitImpl() {
			super();
		}
	};
	/// Pointer to unknown (opaque) type
	public static class time_t extends PointerType {
		public time_t(Pointer address) {
			super(address);
		}
		public time_t() {
			super();
		}
	};
}
